---
/* Import des styles n√©cessaires */
import 'cropperjs/dist/cropper.css';
---

<section class="max-w-6xl mx-auto p-6 space-y-6">
    <!-- Zone d'upload -->
    <div
        id="dropzone"
        class="border-2 border-dashed border-gray-300 rounded-xl p-8 text-center cursor-pointer transition-colors hover:border-gray-500"
    >
        <div class="max-w-md mx-auto">
            <svg class="mx-auto h-12 w-12 text-gray-400 mb-4" stroke="currentColor" fill="none" viewBox="0 0 48 48">
                <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <p class="text-gray-600 text-lg mb-2">
                Glissez-d√©posez des images ici, ou cliquez pour s√©lectionner
            </p>
            <p class="text-sm text-gray-500">
                Formats support√©s: JPG, PNG, WebP, GIF, AVIF, TIFF, BMP, SVG (max 50MB par fichier)
            </p>
        </div>
        <input
            type="file"
            accept="image/*,.avif,.tiff,.tif,.bmp,.svg"
            id="fileInput"
            class="hidden"
            multiple
        />
    </div>

    <!-- Zone de messages -->
    <div id="messageContainer" class="fixed top-4 right-4 z-50 space-y-2"></div>

    <!-- Zone de chargement IA -->
    <div id="aiLoadingPanel" class="hidden bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
        <div class="flex items-center space-x-3">
            <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
            <div>
                <div class="font-medium text-blue-800">Chargement de l'IA...</div>
                <div id="aiLoadingText" class="text-sm text-blue-600">Initialisation des mod√®les de d√©tection...</div>
            </div>
        </div>
        <div class="mt-2 w-full bg-blue-200 rounded-full h-1">
            <div id="aiLoadingProgress" class="bg-blue-600 h-1 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
    </div>

    <!-- Templates pr√©d√©finis -->
    <div id="templatesPanel" class="hidden bg-white rounded-xl shadow-sm border p-6">
        <div class="flex items-center justify-between mb-6">
            <h3 class="text-xl font-semibold text-gray-800">Choisissez un template ou configurez manuellement</h3>
            <button id="manualConfigBtn" class="text-blue-600 hover:text-blue-700 text-sm font-medium">
                Configuration manuelle ‚Üí
            </button>
        </div>
        
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
            <!-- Template E-commerce -->
            <div class="template-card border-2 border-gray-200 rounded-lg p-4 cursor-pointer hover:border-blue-500 transition-colors" data-template="ecommerce">
                <div class="text-center">
                    <div class="w-12 h-12 bg-blue-100 rounded-lg flex items-center justify-center mx-auto mb-3">
                        <svg class="w-6 h-6 text-blue-600" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M3 1a1 1 0 000 2h1.22l.305 1.222a.997.997 0 00.01.042l1.358 5.43-.893.892C3.74 11.846 4.632 14 6.414 14H15a1 1 0 000-2H6.414l1-1H14a1 1 0 00.894-.553l3-6A1 1 0 0017 3H6.28l-.31-1.243A1 1 0 005 1H3zM16 16.5a1.5 1.5 0 11-3 0 1.5 1.5 0 013 0zM6.5 18a1.5 1.5 0 100-3 1.5 1.5 0 010 3z"/>
                        </svg>
                    </div>
                    <h4 class="font-semibold text-gray-800 mb-2">E-commerce</h4>
                    <p class="text-sm text-gray-600 mb-3">Carr√©, IA, WebP optimis√©</p>
                    <div class="text-xs text-gray-500">
                        <div>Format: 1:1</div>
                        <div>ü§ñ IA activ√©e</div>
                        <div>Qualit√©: 85%</div>
                    </div>
                </div>
            </div>

            <!-- Template Instagram -->
            <div class="template-card border-2 border-gray-200 rounded-lg p-4 cursor-pointer hover:border-purple-500 transition-colors" data-template="instagram">
                <div class="text-center">
                    <div class="w-12 h-12 bg-purple-100 rounded-lg flex items-center justify-center mx-auto mb-3">
                        <svg class="w-6 h-6 text-purple-600" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M12.017 0C5.396 0 .029 5.367.029 11.987c0 6.62 5.367 11.987 11.988 11.987s11.987-5.367 11.987-11.987C24.014 5.367 18.647.001 12.017.001zM8.449 16.988c-1.297 0-2.348-1.051-2.348-2.348s1.051-2.348 2.348-2.348 2.348 1.051 2.348 2.348-1.051 2.348-2.348 2.348zm7.119 0c-1.297 0-2.348-1.051-2.348-2.348s1.051-2.348 2.348-2.348 2.348 1.051 2.348 2.348-1.051 2.348-2.348 2.348z"/>
                        </svg>
                    </div>
                    <h4 class="font-semibold text-gray-800 mb-2">Instagram</h4>
                    <p class="text-sm text-gray-600 mb-3">Pack post + story IA</p>
                    <div class="text-xs text-gray-500">
                        <div>Formats: 1:1 + 9:16</div>
                        <div>ü§ñ IA d√©tection</div>
                        <div>Qualit√©: 90%</div>
                    </div>
                </div>
            </div>

            <!-- Template LinkedIn -->
            <div class="template-card border-2 border-gray-200 rounded-lg p-4 cursor-pointer hover:border-blue-700 transition-colors" data-template="linkedin">
                <div class="text-center">
                    <div class="w-12 h-12 bg-blue-700 bg-opacity-10 rounded-lg flex items-center justify-center mx-auto mb-3">
                        <svg class="w-6 h-6 text-blue-700" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
                        </svg>
                    </div>
                    <h4 class="font-semibold text-gray-800 mb-2">LinkedIn</h4>
                    <p class="text-sm text-gray-600 mb-3">Banni√®re pro IA</p>
                    <div class="text-xs text-gray-500">
                        <div>Format: 16:9</div>
                        <div>ü§ñ IA visages</div>
                        <div>Qualit√©: 90%</div>
                    </div>
                </div>
            </div>

            <!-- Template Web -->
            <div class="template-card border-2 border-gray-200 rounded-lg p-4 cursor-pointer hover:border-green-500 transition-colors" data-template="web">
                <div class="text-center">
                    <div class="w-12 h-12 bg-green-100 rounded-lg flex items-center justify-center mx-auto mb-3">
                        <svg class="w-6 h-6 text-green-600" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z"/>
                        </svg>
                    </div>
                    <h4 class="font-semibold text-gray-800 mb-2">Web</h4>
                    <p class="text-sm text-gray-600 mb-3">Performance maximale</p>
                    <div class="text-xs text-gray-500">
                        <div>Format: Original</div>
                        <div>WebP 80%</div>
                        <div>Compression max</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Recommandations intelligentes -->
        <div id="recommendations" class="bg-gradient-to-r from-yellow-50 to-orange-50 border border-yellow-200 rounded-lg p-4 mb-4">
            <h4 class="font-semibold text-orange-800 mb-2 flex items-center">
                <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/>
                </svg>
                Recommandations intelligentes
            </h4>
            <div id="recommendationsList" class="space-y-2 text-sm">
                <p class="text-gray-600">S√©lectionnez des images pour voir les recommandations...</p>
            </div>
        </div>

        <div class="flex justify-center">
            <button id="processTemplateButton" class="px-8 py-3 bg-gradient-to-r from-blue-600 to-purple-600 text-white rounded-lg hover:from-blue-700 hover:to-purple-700 font-medium disabled:opacity-50 disabled:cursor-not-allowed">
                Traiter avec le template s√©lectionn√©
            </button>
        </div>
    </div>

    <!-- Configuration manuelle des traitements -->
    <div id="configPanel" class="hidden bg-gray-50 rounded-xl p-6 space-y-6">
        <div class="flex items-center justify-between">
            <h3 class="text-lg font-semibold text-gray-800">Configuration manuelle</h3>
            <button id="backToTemplatesBtn" class="text-blue-600 hover:text-blue-700 text-sm font-medium">
                ‚Üê Retour aux templates
            </button>
        </div>

        <!-- Estimations d'√©conomies -->
        <div id="savingsEstimate" class="bg-gradient-to-r from-green-50 to-blue-50 border border-green-200 rounded-lg p-4 mb-6">
            <h4 class="font-semibold text-green-800 mb-3 flex items-center">
                <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
                </svg>
                √âconomies estim√©es
            </h4>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
                <div class="bg-white rounded-lg p-3 border border-green-100">
                    <div class="text-gray-600 mb-1">Taille actuelle</div>
                    <div id="currentSize" class="text-lg font-bold text-gray-800">--</div>
                </div>
                
                <div class="bg-white rounded-lg p-3 border border-blue-100">
                    <div class="text-gray-600 mb-1">Taille estim√©e</div>
                    <div id="estimatedSize" class="text-lg font-bold text-blue-600">--</div>
                </div>
                
                <div class="bg-white rounded-lg p-3 border border-green-100">
                    <div class="text-gray-600 mb-1">√âconomie</div>
                    <div id="savings" class="text-lg font-bold text-green-600">--</div>
                    <div id="savingsPercent" class="text-xs text-green-500 mt-1">--</div>
                </div>
            </div>
            
            <!-- Graphique de r√©partition des √©conomies -->
            <div id="savingsBreakdown" class="mt-4 p-3 bg-white rounded-lg border border-gray-100">
                <div class="text-sm font-medium text-gray-700 mb-2">R√©partition des √©conomies :</div>
                <div class="space-y-2">
                    <div id="resizeSavings" class="flex justify-between items-center">
                        <span class="text-sm text-gray-600">Redimensionnement</span>
                        <div class="flex items-center">
                            <div class="w-16 h-2 bg-gray-200 rounded-full mr-2">
                                <div id="resizeSavingsBar" class="h-2 bg-blue-500 rounded-full" style="width: 0%"></div>
                            </div>
                            <span id="resizeSavingsText" class="text-sm font-medium text-gray-700">-</span>
                        </div>
                    </div>
                    
                    <div id="cropSavings" class="flex justify-between items-center">
                        <span class="text-sm text-gray-600">Recadrage</span>
                        <div class="flex items-center">
                            <div class="w-16 h-2 bg-gray-200 rounded-full mr-2">
                                <div id="cropSavingsBar" class="h-2 bg-purple-500 rounded-full" style="width: 0%"></div>
                            </div>
                            <span id="cropSavingsText" class="text-sm font-medium text-gray-700">-</span>
                        </div>
                    </div>
                    
                    <div id="compressionSavings" class="flex justify-between items-center">
                        <span class="text-sm text-gray-600">Compression</span>
                        <div class="flex items-center">
                            <div class="w-16 h-2 bg-gray-200 rounded-full mr-2">
                                <div id="compressionSavingsBar" class="h-2 bg-green-500 rounded-full" style="width: 0%"></div>
                            </div>
                            <span id="compressionSavingsText" class="text-sm font-medium text-gray-700">-</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Impact environnemental estim√© -->
            <div id="environmentalImpact" class="mt-3 p-3 bg-gradient-to-r from-green-100 to-emerald-100 rounded-lg border border-green-200">
                <div class="flex items-center justify-between">
                    <div class="flex items-center">
                        <svg class="w-4 h-4 text-green-600 mr-2" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z"/>
                        </svg>
                        <span class="text-sm text-green-700">Impact environnemental</span>
                    </div>
                    <div class="text-right">
                        <div id="carbonSaved" class="text-sm font-semibold text-green-800">-- g CO‚ÇÇ</div>
                        <div class="text-xs text-green-600">√©conomis√©s en transfert</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- S√©lection des actions -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <!-- Redimensionnement -->
            <div class="bg-white p-4 rounded-lg border">
                <label class="flex items-center space-x-2 mb-3">
                    <input type="checkbox" id="enableResize" class="action-checkbox">
                    <span class="font-medium">Redimensionner</span>
                </label>
                <div id="resizeOptions" class="space-y-3 opacity-50">
                    <div>
                        <label class="block text-sm text-gray-600 mb-1">Taille (%)</label>
                        <input type="range" id="resizePercent" min="10" max="200" step="5" value="80" class="w-full">
                        <div class="flex justify-between text-xs text-gray-500 mt-1">
                            <span>10%</span>
                            <span id="resizePercentValue" class="font-medium">80%</span>
                            <span>200%</span>
                        </div>
                        <p class="text-xs text-gray-400 mt-1">Les proportions sont conserv√©es</p>
                    </div>
                </div>
            </div>

            <!-- Recadrage -->
            <div class="bg-white p-4 rounded-lg border">
                <label class="flex items-center space-x-2 mb-3">
                    <input type="checkbox" id="enableCrop" class="action-checkbox">
                    <span class="font-medium">Recadrer</span>
                </label>
                <div id="cropOptions" class="space-y-3 opacity-50">
                    <div>
                        <label class="block text-sm text-gray-600 mb-1">Format:</label>
                        <select id="aspectRatio" class="w-full border rounded px-2 py-1 text-sm">
                            <option value="1/1">1:1 (Carr√©)</option>
                            <option value="16/9">16:9 (Paysage)</option>
                            <option value="4/3">4:3 (Standard)</option>
                            <option value="3/4">3:4 (Portrait)</option>
                            <option value="9/16">9:16 (Portrait mobile)</option>
                            <option value="free">Libre</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm text-gray-600 mb-1">Position:</label>
                        <select id="cropPosition" class="w-full border rounded px-2 py-1 text-sm">
                            <option value="intelligent">ü§ñ IA - D√©tection automatique</option>
                            <option value="center">Centre</option>
                            <option value="top">Haut</option>
                            <option value="bottom">Bas</option>
                            <option value="left">Gauche</option>
                            <option value="right">Droite</option>
                            <option value="manual">Manuel (premi√®re image)</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Conversion -->
            <div class="bg-white p-4 rounded-lg border">
                <label class="flex items-center space-x-2 mb-3">
                    <input type="checkbox" id="enableConvert" class="action-checkbox">
                    <span class="font-medium">Convertir</span>
                </label>
                <div id="convertOptions" class="space-y-3 opacity-50">
                    <div>
                        <label class="block text-sm text-gray-600 mb-1">Format:</label>
                        <select id="outputFormat" class="w-full border rounded px-2 py-1 text-sm">
                            <option value="webp">WebP</option>
                            <option value="jpeg">JPEG</option>
                            <option value="png">PNG</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm text-gray-600 mb-1">Qualit√©:</label>
                        <input type="range" id="quality" min="60" max="100" step="5" value="90" class="w-full">
                        <div class="flex justify-between text-xs text-gray-500 mt-1">
                            <span>60%</span>
                            <span id="qualityValue" class="font-medium">90%</span>
                            <span>100%</span>
                        </div>
                        <p class="text-xs text-gray-400 mt-1">Compression optimis√©e</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Pr√©visualisation pour recadrage manuel ou IA -->
        <div id="cropPreview" class="hidden">
            <h4 class="font-medium mb-2">Pr√©visualisation du recadrage :</h4>
            <div class="max-w-md mx-auto relative">
                <img id="previewImage" class="max-w-full rounded-lg">
                <!-- Overlay pour les d√©tections IA -->
                <div id="aiDetectionOverlay" class="absolute inset-0 pointer-events-none hidden">
                    <!-- Les d√©tections seront ajout√©es ici dynamiquement -->
                </div>
            </div>
            <div id="aiDetectionInfo" class="mt-2 text-sm text-gray-600 hidden">
                <!-- Informations sur les d√©tections -->
            </div>
        </div>

        <!-- Informations sur les fichiers -->
        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 text-sm">
            <div class="flex justify-between items-center">
                <div>
                    <span id="imageCount">0</span> image(s) s√©lectionn√©e(s)
                    <span id="totalSize" class="text-gray-600 ml-2"></span>
                </div>
                <div id="performanceEstimate" class="text-gray-600"></div>
            </div>
        </div>

        <!-- Boutons d'action -->
        <div class="flex justify-between items-center pt-4 border-t">
            <button id="resetButton" class="px-4 py-2 text-gray-600 border border-gray-300 rounded hover:bg-gray-50">
                R√©initialiser
            </button>
            <button id="processButton" class="px-6 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed">
                Traiter les images
            </button>
        </div>
    </div>

    <!-- Barre de progression -->
    <div id="progressPanel" class="hidden bg-white rounded-lg p-6 border">
        <div class="flex justify-between items-center mb-4">
            <h3 class="font-semibold">Traitement en cours...</h3>
            <button id="cancelButton" class="px-3 py-1 text-sm text-red-600 border border-red-300 rounded hover:bg-red-50">
                Annuler
            </button>
        </div>
        <div class="w-full bg-gray-200 rounded-full h-2 mb-2">
            <div id="progressBar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
        <div class="flex justify-between text-sm text-gray-600">
            <span id="progressText">Initialisation...</span>
            <span id="progressPercent">0%</span>
        </div>
        <div id="timeRemaining" class="text-xs text-gray-500 mt-2"></div>
        
        <!-- √âconomies r√©alis√©es en temps r√©el -->
        <div id="realTimeSavings" class="mt-4 p-3 bg-green-50 border border-green-200 rounded-lg">
            <div class="text-sm font-medium text-green-800 mb-2">√âconomies r√©alis√©es :</div>
            <div class="flex justify-between text-sm">
                <span class="text-gray-600">Progression :</span>
                <span id="currentSavings" class="font-medium text-green-600">0 MB √©conomis√©s</span>
            </div>
        </div>
        
        <!-- Liste des erreurs -->
        <div id="errorsList" class="hidden mt-4 p-3 bg-red-50 border border-red-200 rounded">
            <h4 class="text-sm font-medium text-red-800 mb-2">Erreurs rencontr√©es:</h4>
            <ul id="errorsContent" class="text-xs text-red-700 space-y-1"></ul>
        </div>
    </div>

    <!-- √âcran de r√©sultats final -->
    <div id="resultsPanel" class="hidden bg-gradient-to-br from-green-50 to-blue-50 rounded-xl border-2 border-green-200 p-6">
        <div class="text-center mb-6">
            <div class="w-16 h-16 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-4">
                <svg class="w-8 h-8 text-green-600" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
                </svg>
            </div>
            <h3 class="text-2xl font-bold text-gray-800 mb-2">Traitement termin√© !</h3>
            <p class="text-gray-600">Vos images ont √©t√© optimis√©es avec succ√®s</p>
        </div>

        <!-- Statistiques finales -->
        <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
            <div class="bg-white rounded-lg p-4 text-center border">
                <div class="text-2xl font-bold text-blue-600" id="finalImagesProcessed">--</div>
                <div class="text-sm text-gray-600">Images trait√©es</div>
            </div>
            <div class="bg-white rounded-lg p-4 text-center border">
                <div class="text-2xl font-bold text-green-600" id="finalSavingsAmount">--</div>
                <div class="text-sm text-gray-600">√âconomis√©s</div>
            </div>
            <div class="bg-white rounded-lg p-4 text-center border">
                <div class="text-2xl font-bold text-purple-600" id="finalSavingsPercent">--%</div>
                <div class="text-sm text-gray-600">R√©duction</div>
            </div>
            <div class="bg-white rounded-lg p-4 text-center border">
                <div class="text-2xl font-bold text-orange-600" id="finalCarbonSaved">--g</div>
                <div class="text-sm text-gray-600">CO‚ÇÇ √©conomis√©</div>
            </div>
        </div>

        <!-- D√©tails du traitement -->
        <div class="bg-white rounded-lg p-4 mb-6 border">
            <h4 class="font-semibold text-gray-800 mb-3">D√©tails du traitement</h4>
            <div id="processingDetails" class="space-y-2 text-sm text-gray-600">
                <!-- Sera rempli dynamiquement -->
            </div>
        </div>

        <!-- Impact environnemental d√©taill√© -->
        <div class="bg-gradient-to-r from-green-100 to-emerald-100 rounded-lg p-4 mb-6 border border-green-200">
            <div class="flex items-center mb-3">
                <svg class="w-5 h-5 text-green-600 mr-2" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z"/>
                </svg>
                <h4 class="font-semibold text-green-800">Impact environnemental</h4>
            </div>
            <div id="environmentalDetails" class="text-sm text-green-700">
                <!-- Sera rempli dynamiquement -->
            </div>
        </div>

        <!-- Actions -->
        <div class="flex flex-col sm:flex-row gap-3 justify-center">
            <button id="newProcessingBtn" class="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium">
                Traiter d'autres images
            </button>
            <button id="downloadResultsBtn" class="px-6 py-3 bg-gray-600 text-white rounded-lg hover:bg-gray-700 font-medium">
                T√©l√©charger le rapport
            </button>
        </div>
    </div>
</section>

<style>
/* Styles pour les messages */
.message {
    @apply px-4 py-3 rounded-lg shadow-lg transform transition-all duration-300 ease-in-out;
    animation: slideIn 0.3s ease-out;
}

.message-info {
    @apply bg-blue-500 text-white;
}

.message-success {
    @apply bg-green-500 text-white;
}

.message-error {
    @apply bg-red-500 text-white;
}

.message-warning {
    @apply bg-yellow-500 text-white;
}

@keyframes slideIn {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

/* Animations pour les barres de progression des √©conomies */
#resizeSavingsBar, #cropSavingsBar, #compressionSavingsBar {
    transition: width 0.5s ease-in-out;
}

/* Styles pour les templates */
.template-card.selected {
    @apply border-blue-500 bg-blue-50;
}

.template-card.selected .bg-blue-100 {
    @apply bg-blue-200;
}

.template-card.selected .bg-purple-100 {
    @apply bg-purple-200;
}

.template-card.selected .bg-blue-700 {
    @apply bg-blue-800;
}

.template-card.selected .bg-green-100 {
    @apply bg-green-200;
}

/* Animation de scroll fluide */
html {
    scroll-behavior: smooth;
}

/* Styles pour les d√©tections IA */
.ai-detection-box {
    position: absolute;
    border: 2px solid #3b82f6;
    background: rgba(59, 130, 246, 0.1);
    border-radius: 4px;
    pointer-events: none;
}

.ai-detection-face {
    border-color: #10b981;
    background: rgba(16, 185, 129, 0.1);
}

.ai-detection-person {
    border-color: #f59e0b;
    background: rgba(245, 158, 11, 0.1);
}

.ai-detection-label {
    position: absolute;
    top: -24px;
    left: 0;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 11px;
    white-space: nowrap;
}
</style>

<script>
// --- CONFIGURATION ---
const CONFIG = {
    MAX_FILE_SIZE: 50 * 1024 * 1024,
    MAX_TOTAL_SIZE: 200 * 1024 * 1024,
    MAX_DIMENSION: 4096,
    CHUNK_SIZE: 5,
    
    COMPRESSION_FACTORS: {
        webp: { base: 0.7, quality: 0.3 },
        jpeg: { base: 0.8, quality: 0.4 },
        png: { base: 0.9, quality: 0.1 }
    },
    
    CO2_FACTOR_PER_MB: 0.5,
    
    // Configuration IA
    AI: {
        FACE_CONFIDENCE: 0.7,
        OBJECT_CONFIDENCE: 0.5,
        PRIORITY_CLASSES: ['person', 'cat', 'dog', 'bird', 'horse'],
        MAX_DETECTION_SIZE: 800
    },
    
    // Templates avec IA
    TEMPLATES: {
        ecommerce: {
            name: 'E-commerce',
            resize: { enabled: true, percent: 80 },
            crop: { enabled: true, aspectRatio: '1/1', position: 'intelligent' },
            convert: { enabled: true, format: 'webp', quality: 85 },
            suffix: '_ecommerce'
        },
        instagram: {
            name: 'Instagram',
            resize: { enabled: false },
            crop: { enabled: true, aspectRatio: '1/1', position: 'intelligent' },
            convert: { enabled: true, format: 'webp', quality: 90 },
            suffix: '_instagram',
            multiFormat: [
                { aspectRatio: '1/1', suffix: '_post' },
                { aspectRatio: '9/16', suffix: '_story' }
            ]
        },
        linkedin: {
            name: 'LinkedIn',
            resize: { enabled: true, percent: 90 },
            crop: { enabled: true, aspectRatio: '16/9', position: 'intelligent' },
            convert: { enabled: true, format: 'webp', quality: 90 },
            suffix: '_linkedin'
        },
        web: {
            name: 'Web',
            resize: { enabled: false },
            crop: { enabled: false },
            convert: { enabled: true, format: 'webp', quality: 80 },
            suffix: '_web'
        }
    }
};

// --- MODULE IA SIMPLIFI√â ---
class AIDetector {
    constructor() {
        this.isLoaded = false;
        this.faceModel = null;
        this.objectModel = null;
        this.loadingPromise = null;
    }

    async initialize() {
        if (this.isLoaded) return true;
        if (this.loadingPromise) return this.loadingPromise;

        this.loadingPromise = this._loadModels();
        return this.loadingPromise;
    }

    async _loadModels() {
        try {
            updateAIProgress(10, 'Chargement TensorFlow.js...');
            
            // Charger TensorFlow.js et les mod√®les de mani√®re s√©quentielle
            await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js');
            
            updateAIProgress(30, 'Chargement du mod√®le de d√©tection de visages...');
            await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.js');
            
            updateAIProgress(50, 'Initialisation du mod√®le de visages...');
            this.faceModel = await blazeface.load();
            
            updateAIProgress(70, 'Chargement du mod√®le de d√©tection d\'objets...');
            await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.js');
            
            updateAIProgress(90, 'Initialisation du mod√®le d\'objets...');
            this.objectModel = await cocoSsd.load();
            
            updateAIProgress(100, 'Mod√®les IA charg√©s avec succ√®s !');
            
            this.isLoaded = true;
            return true;
        } catch (error) {
            console.error('Erreur chargement IA:', error);
            this.isLoaded = false;
            throw error;
        }
    }

    async detect(imageElement) {
        if (!this.isLoaded) {
            throw new Error('Mod√®les IA non charg√©s');
        }

        const canvas = this._createDetectionCanvas(imageElement);
        const [faces, objects] = await Promise.all([
            this._detectFaces(canvas),
            this._detectObjects(canvas)
        ]);

        return this._processDetections(faces, objects, imageElement);
    }

    _createDetectionCanvas(imageElement) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        const maxSize = CONFIG.AI.MAX_DETECTION_SIZE;
        const scale = Math.min(maxSize / imageElement.naturalWidth, maxSize / imageElement.naturalHeight, 1);
        
        canvas.width = imageElement.naturalWidth * scale;
        canvas.height = imageElement.naturalHeight * scale;
        
        ctx.drawImage(imageElement, 0, 0, canvas.width, canvas.height);
        return { canvas, scale };
    }

    async _detectFaces(canvasData) {
        const faces = await this.faceModel.estimateFaces(canvasData.canvas, false);
        return faces.map(face => ({
            bbox: [
                face.topLeft[0] / canvasData.scale,
                face.topLeft[1] / canvasData.scale,
                (face.bottomRight[0] - face.topLeft[0]) / canvasData.scale,
                (face.bottomRight[1] - face.topLeft[1]) / canvasData.scale
            ],
            confidence: face.probability ? face.probability[0] : 0.9,
            type: 'face'
        })).filter(face => face.confidence > CONFIG.AI.FACE_CONFIDENCE);
    }

    async _detectObjects(canvasData) {
        const objects = await this.objectModel.detect(canvasData.canvas);
        return objects.map(obj => ({
            bbox: [
                obj.bbox[0] / canvasData.scale,
                obj.bbox[1] / canvasData.scale,
                obj.bbox[2] / canvasData.scale,
                obj.bbox[3] / canvasData.scale
            ],
            confidence: obj.score,
            type: 'object',
            class: obj.class
        })).filter(obj => obj.confidence > CONFIG.AI.OBJECT_CONFIDENCE);
    }

    _processDetections(faces, objects, imageElement) {
        const allDetections = [...faces, ...objects];
        const recommended = this._findMainSubject(faces, objects);
        
        return {
            faces,
            objects,
            recommended,
            all: allDetections
        };
    }

    _findMainSubject(faces, objects) {
        // Priorit√© aux visages
        if (faces.length > 0) {
            return this._selectBestDetection(faces);
        }
        
        // Puis aux objets prioritaires
        const priorityObjects = objects.filter(obj => 
            CONFIG.AI.PRIORITY_CLASSES.includes(obj.class)
        );
        
        if (priorityObjects.length > 0) {
            return this._selectBestDetection(priorityObjects);
        }
        
        // Enfin tout autre objet
        if (objects.length > 0) {
            return this._selectBestDetection(objects);
        }
        
        return null;
    }

    _selectBestDetection(detections) {
        const best = detections.reduce((best, current) => {
            const currentScore = (current.bbox[2] * current.bbox[3]) * current.confidence;
            const bestScore = (best.bbox[2] * best.bbox[3]) * best.confidence;
            return currentScore > bestScore ? current : best;
        });
        
        return {
            ...best,
            center: {
                x: best.bbox[0] + best.bbox[2] / 2,
                y: best.bbox[1] + best.bbox[3] / 2
            }
        };
    }

    calculateIntelligentCrop(detections, aspectRatio, imageWidth, imageHeight) {
        const targetRatio = parseAspectRatio(aspectRatio);
        if (isNaN(targetRatio)) return null;
        
        if (!detections.recommended) {
            return this._calculateCenterCrop(targetRatio, imageWidth, imageHeight);
        }
        
        return this._calculateSubjectCrop(detections.recommended, targetRatio, imageWidth, imageHeight);
    }

    _calculateSubjectCrop(subject, targetRatio, imageWidth, imageHeight) {
        const currentRatio = imageWidth / imageHeight;
        let cropWidth, cropHeight;
        
        if (currentRatio > targetRatio) {
            cropHeight = imageHeight;
            cropWidth = cropHeight * targetRatio;
        } else {
            cropWidth = imageWidth;
            cropHeight = cropWidth / targetRatio;
        }
        
        // Centrer sur le sujet avec marges
        const margin = 0.1;
        const subjectBox = subject.bbox;
        const subjectCenter = subject.center;
        
        let cropX = Math.max(0, Math.min(subjectCenter.x - cropWidth / 2, imageWidth - cropWidth));
        let cropY = Math.max(0, Math.min(subjectCenter.y - cropHeight / 2, imageHeight - cropHeight));
        
        // Ajuster pour garder le sujet dans le cadre
        const minX = Math.max(0, subjectBox[0] - subjectBox[2] * margin);
        const maxX = Math.min(imageWidth, subjectBox[0] + subjectBox[2] * (1 + margin));
        const minY = Math.max(0, subjectBox[1] - subjectBox[3] * margin);
        const maxY = Math.min(imageHeight, subjectBox[1] + subjectBox[3] * (1 + margin));
        
        if (cropX + cropWidth < maxX) {
            cropX = Math.max(0, maxX - cropWidth);
        }
        if (cropX > minX) {
            cropX = Math.min(minX, imageWidth - cropWidth);
        }
        if (cropY + cropHeight < maxY) {
            cropY = Math.max(0, maxY - cropHeight);
        }
        if (cropY > minY) {
            cropY = Math.min(minY, imageHeight - cropHeight);
        }
        
        return {
            x: cropX,
            y: cropY,
            width: cropWidth,
            height: cropHeight
        };
    }

    _calculateCenterCrop(targetRatio, imageWidth, imageHeight) {
        const currentRatio = imageWidth / imageHeight;
        let cropWidth, cropHeight, cropX, cropY;
        
        if (currentRatio > targetRatio) {
            cropHeight = imageHeight;
            cropWidth = cropHeight * targetRatio;
            cropY = 0;
            cropX = (imageWidth - cropWidth) / 2;
        } else {
            cropWidth = imageWidth;
            cropHeight = cropWidth / targetRatio;
            cropX = 0;
            cropY = (imageHeight - cropHeight) / 2;
        }
        
        return { x: cropX, y: cropY, width: cropWidth, height: cropHeight };
    }
}

// Instance globale du d√©tecteur IA
const aiDetector = new AIDetector();

// --- CHARGEMENT DYNAMIQUE DES SCRIPTS ---
async function loadScript(src) {
    return new Promise((resolve, reject) => {
        // V√©rifier si le script est d√©j√† charg√©
        if (document.querySelector(`script[src="${src}"]`)) {
            resolve();
            return;
        }
        
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
    });
}

async function loadDependencies() {
    try {
        // Charger Cropper.js
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css';
        document.head.appendChild(link);
        
        await Promise.all([
            loadScript('https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js'),
            loadScript('https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js')
        ]);
        return true;
    } catch (error) {
        console.error('Erreur chargement d√©pendances:', error);
        return false;
    }
}

// --- R√âF√âRENCES DOM ---
const dropzone = document.getElementById('dropzone');
const fileInput = document.getElementById('fileInput');
const templatesPanel = document.getElementById('templatesPanel');
const configPanel = document.getElementById('configPanel');
const cropPreview = document.getElementById('cropPreview');
const previewImage = document.getElementById('previewImage');
const imageCount = document.getElementById('imageCount');
const totalSize = document.getElementById('totalSize');
const performanceEstimate = document.getElementById('performanceEstimate');
const progressPanel = document.getElementById('progressPanel');
const resultsPanel = document.getElementById('resultsPanel');
const progressBar = document.getElementById('progressBar');
const progressText = document.getElementById('progressText');
const progressPercent = document.getElementById('progressPercent');
const timeRemaining = document.getElementById('timeRemaining');
const cancelButton = document.getElementById('cancelButton');
const errorsList = document.getElementById('errorsList');
const errorsContent = document.getElementById('errorsContent');
const messageContainer = document.getElementById('messageContainer');

// Boutons de navigation
const manualConfigBtn = document.getElementById('manualConfigBtn');
const backToTemplatesBtn = document.getElementById('backToTemplatesBtn');
const processTemplateButton = document.getElementById('processTemplateButton');
const newProcessingBtn = document.getElementById('newProcessingBtn');
const downloadResultsBtn = document.getElementById('downloadResultsBtn');

// √âl√©ments IA
const aiLoadingPanel = document.getElementById('aiLoadingPanel');
const aiLoadingText = document.getElementById('aiLoadingText');
const aiLoadingProgress = document.getElementById('aiLoadingProgress');
const aiDetectionOverlay = document.getElementById('aiDetectionOverlay');
const aiDetectionInfo = document.getElementById('aiDetectionInfo');

// √âl√©ments de configuration
const enableResize = document.getElementById('enableResize');
const enableCrop = document.getElementById('enableCrop');
const enableConvert = document.getElementById('enableConvert');
const resizeOptions = document.getElementById('resizeOptions');
const cropOptions = document.getElementById('cropOptions');
const convertOptions = document.getElementById('convertOptions');
const resizePercentSlider = document.getElementById('resizePercent');
const resizePercentValue = document.getElementById('resizePercentValue');
const qualitySlider = document.getElementById('quality');
const qualityValue = document.getElementById('qualityValue');
const cropPosition = document.getElementById('cropPosition');
const aspectRatio = document.getElementById('aspectRatio');

// √âl√©ments des √©conomies
const currentSize = document.getElementById('currentSize');
const estimatedSize = document.getElementById('estimatedSize');
const savings = document.getElementById('savings');
const savingsPercent = document.getElementById('savingsPercent');
const resizeSavingsBar = document.getElementById('resizeSavingsBar');
const resizeSavingsText = document.getElementById('resizeSavingsText');
const cropSavingsBar = document.getElementById('cropSavingsBar');
const cropSavingsText = document.getElementById('cropSavingsText');
const compressionSavingsBar = document.getElementById('compressionSavingsBar');
const compressionSavingsText = document.getElementById('compressionSavingsText');
const carbonSaved = document.getElementById('carbonSaved');
const currentSavings = document.getElementById('currentSavings');

// Recommandations
const recommendationsList = document.getElementById('recommendationsList');

const processButton = document.getElementById('processButton');
const resetButton = document.getElementById('resetButton');

// --- √âTAT GLOBAL ---
let selectedFiles = [];
let cropperInstance = null;
let manualCropData = null;
let abortController = null;
let startTime = null;
let preloadedImage = null;
let imageCache = new Map();
let realTimeSavingsTotal = 0;
let selectedTemplate = null;
let finalResults = null;
let aiDetectionCache = new Map();

// --- FONCTIONS UTILITAIRES ---
function formatFileSize(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function formatTime(milliseconds) {
    const seconds = Math.floor(milliseconds / 1000);
    if (seconds < 60) {
        return `${seconds}s`;
    }
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes}m ${remainingSeconds}s`;
}

function parseAspectRatio(ratioStr) {
    if (ratioStr === 'free') return NaN;
    const [w, h] = ratioStr.split('/').map(Number);
    return h > 0 ? w / h : 1;
}

function updateAIProgress(percent, text) {
    if (aiLoadingPanel) {
        aiLoadingPanel.classList.remove('hidden');
        if (aiLoadingProgress) aiLoadingProgress.style.width = percent + '%';
        if (aiLoadingText) aiLoadingText.textContent = text;
    }
}

function showMessage(message, type = 'info') {
    const messageEl = document.createElement('div');
    messageEl.className = `message message-${type}`;
    messageEl.textContent = message;
    messageContainer.appendChild(messageEl);
    
    setTimeout(() => {
        messageEl.style.opacity = '0';
        setTimeout(() => messageEl.remove(), 300);
    }, 3000);
}

// --- FONCTIONS DE GESTION D'UPLOAD ---
function handleDragOver(e) {
    e.preventDefault();
    dropzone.classList.add('border-blue-500', 'bg-blue-50');
}

function handleDragLeave(e) {
    e.preventDefault();
    dropzone.classList.remove('border-blue-500', 'bg-blue-50');
}

function handleDrop(e) {
    e.preventDefault();
    dropzone.classList.remove('border-blue-500', 'bg-blue-50');
    const files = Array.from(e.dataTransfer.files).filter(file => file.type.startsWith('image/'));
    handleFiles(files);
}

function handleFileSelect(e) {
    const files = Array.from(e.target.files);
    handleFiles(files);
    fileInput.value = '';
}

function handleFiles(files) {
    const validFiles = [];
    let totalValidSize = 0;
    
    for (const file of files) {
        if (file.size > CONFIG.MAX_FILE_SIZE) {
            showMessage(`${file.name} d√©passe la taille maximale de 50MB`, 'warning');
            continue;
        }
        
        if (totalValidSize + file.size > CONFIG.MAX_TOTAL_SIZE) {
            showMessage('La taille totale des fichiers d√©passe 200MB', 'warning');
            break;
        }
        
        validFiles.push(file);
        totalValidSize += file.size;
    }
    
    if (validFiles.length === 0) {
        return;
    }
    
    selectedFiles = validFiles;
    updateUI();
    updateSavingsEstimate();
    updateRecommendations();
    
    // Initialiser l'IA si n√©cessaire
    if (cropPosition.value === 'intelligent' && !aiDetector.isLoaded) {
        initializeAI();
    }
    
    // Pr√©charger la premi√®re image si n√©cessaire
    if (validFiles.length > 0 && enableCrop.checked && (cropPosition.value === 'manual' || cropPosition.value === 'intelligent')) {
        preloadFirstImage(validFiles[0]);
    }
    
    showMessage(`${validFiles.length} image(s) s√©lectionn√©e(s)`, 'info');
    
    // Scroll automatique vers les templates
    setTimeout(() => {
        templatesPanel.scrollIntoView({ behavior: 'smooth' });
    }, 500);
}

async function preloadFirstImage(file) {
    if (preloadedImage && preloadedImage.file === file) {
        return preloadedImage;
    }
    
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            preloadedImage = {
                file: file,
                dataUrl: e.target.result
            };
            resolve(preloadedImage);
        };
        reader.onerror = () => {
            reject(new Error(`Impossible de pr√©charger l'image: ${file.name}`));
        };
        reader.readAsDataURL(file);
    });
}

// --- FONCTIONS DE TEMPLATES ---
function applyTemplate(templateName) {
    const template = CONFIG.TEMPLATES[templateName];
    if (!template) return;
    
    enableResize.checked = template.resize.enabled;
    if (template.resize.enabled) {
        resizePercentSlider.value = template.resize.percent;
        resizePercentValue.textContent = template.resize.percent + '%';
    }
    
    enableCrop.checked = template.crop.enabled;
    if (template.crop.enabled) {
        aspectRatio.value = template.crop.aspectRatio;
        cropPosition.value = template.crop.position;
    }
    
    enableConvert.checked = template.convert.enabled;
    if (template.convert.enabled) {
        document.getElementById('outputFormat').value = template.convert.format;
        qualitySlider.value = template.convert.quality;
        qualityValue.textContent = template.convert.quality + '%';
    }
    
    updateActionStates();
    
    // Initialiser l'IA si le template l'utilise
    if (template.crop.position === 'intelligent' && !aiDetector.isLoaded) {
        initializeAI();
    }
}

// --- FONCTIONS D'INITIALISATION IA ---
async function initializeAI() {
    try {
        aiLoadingPanel.classList.remove('hidden');
        await aiDetector.initialize();
        aiLoadingPanel.classList.add('hidden');
        showMessage('IA pr√™te ! D√©tection automatique activ√©e ü§ñ', 'success');
        return true;
    } catch (error) {
        console.error('Erreur initialisation IA:', error);
        aiLoadingPanel.classList.add('hidden');
        showMessage('IA non disponible, utilisation du mode standard', 'warning');
        
        // Fallback au mode centre
        if (cropPosition.value === 'intelligent') {
            cropPosition.value = 'center';
        }
        return false;
    }
}

// --- FONCTIONS DE RECOMMANDATIONS ---
function updateRecommendations() {
    if (selectedFiles.length === 0) {
        recommendationsList.innerHTML = '<p class="text-gray-600">S√©lectionnez des images pour voir les recommandations...</p>';
        return;
    }
    
    const recommendations = generateRecommendations();
    let html = '';
    
    recommendations.forEach(rec => {
        const iconColor = rec.priority === 'high' ? 'text-red-500' : 
                        rec.priority === 'medium' ? 'text-yellow-500' : 'text-blue-500';
        html += `
            <div class="flex items-start space-x-2">
                <svg class="w-4 h-4 ${iconColor} mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/>
                </svg>
                <span class="text-gray-700">${rec.message}</span>
            </div>
        `;
    });
    
    recommendationsList.innerHTML = html;
}

function generateRecommendations() {
    const recommendations = [];
    
    if (selectedFiles.length === 0) return recommendations;
    
    const fileTypes = selectedFiles.map(f => f.type.split('/')[1]);
    const hasPNG = fileTypes.includes('png');
    const hasJPEG = fileTypes.includes('jpeg');
    const avgSize = selectedFiles.reduce((sum, f) => sum + f.size, 0) / selectedFiles.length;
    
    // Recommandation IA
    if (enableCrop.checked && cropPosition.value !== 'intelligent') {
        recommendations.push({
            priority: 'high',
            message: 'ü§ñ Essayez le recadrage intelligent par IA pour centrer automatiquement sur les sujets !'
        });
    }
    
    // Recommandations de format
    if (hasPNG && !enableConvert.checked) {
        recommendations.push({
            priority: 'high',
            message: 'Convertissez vos PNG en WebP pour √©conomiser jusqu\'√† 50% d\'espace !'
        });
    }
    
    if (hasJPEG && document.getElementById('outputFormat').value !== 'webp') {
        recommendations.push({
            priority: 'medium',
            message: 'Le format WebP offre une meilleure compression que JPEG sans perte visible.'
        });
    }
    
    const quality = parseInt(qualitySlider.value);
    if (quality > 90) {
        recommendations.push({
            priority: 'medium',
            message: 'Une qualit√© de 85-90% est g√©n√©ralement suffisante et r√©duit significativement la taille.'
        });
    }
    
    if (avgSize > 2 * 1024 * 1024 && !enableResize.checked) {
        recommendations.push({
            priority: 'high',
            message: 'Vos images sont volumineuses. R√©duisez leur taille de 20-30% pour un web plus rapide.'
        });
    }
    
    if (selectedFiles.length > 1 && !enableCrop.checked) {
        recommendations.push({
            priority: 'low',
            message: 'Standardisez vos formats avec le recadrage pour une pr√©sentation uniforme.'
        });
    }
    
    const score = calculatePerformanceScore();
    if (score < 70) {
        recommendations.push({
            priority: 'high',
            message: `Score d'optimisation: ${score}/100. Activez plus d'options pour am√©liorer les performances.`
        });
    } else if (score >= 85) {
        recommendations.push({
            priority: 'low',
            message: `Excellent ! Score d'optimisation: ${score}/100. Configuration optimale d√©tect√©e.`
        });
    }
    
    return recommendations;
}

function calculatePerformanceScore() {
    let score = 0;
    
    if (enableConvert.checked) {
        const format = document.getElementById('outputFormat').value;
        if (format === 'webp') score += 30;
        else if (format === 'jpeg') score += 20;
        else score += 10;
        
        const quality = parseInt(qualitySlider.value);
        if (quality >= 80 && quality <= 90) score += 15;
        else if (quality >= 70 && quality < 80) score += 10;
    }
    
    if (enableResize.checked) {
        const percent = parseInt(resizePercentSlider.value);
        if (percent >= 70 && percent <= 90) score += 25;
        else if (percent >= 50 && percent < 70) score += 20;
        else score += 10;
    }
    
    if (enableCrop.checked) {
        score += 15;
        if (cropPosition.value === 'intelligent') score += 10;
    }
    
    const activeOptimizations = [enableResize.checked, enableCrop.checked, enableConvert.checked].filter(Boolean).length;
    if (activeOptimizations >= 2) score += 15;
    
    return Math.min(score, 100);
}

// --- FONCTIONS D'ESTIMATIONS D'√âCONOMIES ---
function updateSavingsEstimate() {
    if (selectedFiles.length === 0) return;
    
    const totalCurrentSize = selectedFiles.reduce((sum, file) => sum + file.size, 0);
    let estimatedTotalSize = 0;
    const breakdown = {
        resize: 0,
        crop: 0,
        compression: 0
    };
    
    selectedFiles.forEach(file => {
        const estimates = estimateFileSavings(file);
        estimatedTotalSize += estimates.estimatedSize;
        breakdown.resize += estimates.breakdown.resize;
        breakdown.crop += estimates.breakdown.crop;
        breakdown.compression += estimates.breakdown.compression;
    });
    
    currentSize.textContent = formatFileSize(totalCurrentSize);
    estimatedSize.textContent = formatFileSize(estimatedTotalSize);
    
    const totalSavings = totalCurrentSize - estimatedTotalSize;
    const savingsPercentValue = ((totalSavings / totalCurrentSize) * 100).toFixed(1);
    
    savings.textContent = formatFileSize(Math.max(0, totalSavings));
    savingsPercent.textContent = `${savingsPercentValue}% d'√©conomie`;
    
    updateSavingsBreakdown(breakdown, totalSavings);
    
    const carbonSavings = (totalSavings / (1024 * 1024)) * CONFIG.CO2_FACTOR_PER_MB;
    carbonSaved.textContent = `${carbonSavings.toFixed(1)} g CO‚ÇÇ`;
    
    if (savingsPercentValue > 30) {
        savings.className = 'text-lg font-bold text-green-600';
        savingsPercent.className = 'text-xs text-green-500 mt-1';
    } else if (savingsPercentValue > 10) {
        savings.className = 'text-lg font-bold text-blue-600';
        savingsPercent.className = 'text-xs text-blue-500 mt-1';
    } else {
        savings.className = 'text-lg font-bold text-orange-600';
        savingsPercent.className = 'text-xs text-orange-500 mt-1';
    }
}

function estimateFileSavings(file) {
    let estimatedSize = file.size;
    const breakdown = { resize: 0, crop: 0, compression: 0 };
    
    if (enableResize.checked) {
        const scale = parseFloat(resizePercentSlider.value) / 100;
        const resizeFactor = Math.pow(scale, 2);
        const newSizeAfterResize = estimatedSize * resizeFactor;
        breakdown.resize = estimatedSize - newSizeAfterResize;
        estimatedSize = newSizeAfterResize;
    }
    
    if (enableCrop.checked) {
        const cropFactor = estimateCropFactor();
        const newSizeAfterCrop = estimatedSize * cropFactor;
        breakdown.crop = estimatedSize - newSizeAfterCrop;
        estimatedSize = newSizeAfterCrop;
    }
    
    if (enableConvert.checked) {
        const compressionFactor = estimateCompressionFactor(file);
        const newSizeAfterCompression = estimatedSize * compressionFactor;
        breakdown.compression = estimatedSize - newSizeAfterCompression;
        estimatedSize = newSizeAfterCompression;
    }
    
    return {
        estimatedSize: Math.max(estimatedSize, file.size * 0.1),
        breakdown
    };
}

function estimateCropFactor() {
    const aspectRatioStr = aspectRatio.value;
    if (aspectRatioStr === 'free') return 0.85;
    
    const cropFactors = {
        '1/1': 0.7,
        '16/9': 0.8,
        '4/3': 0.85,
        '3/4': 0.8,
        '9/16': 0.7
    };
    
    return cropFactors[aspectRatioStr] || 0.8;
}

function estimateCompressionFactor(file) {
    const outputFormat = document.getElementById('outputFormat').value;
    const quality = parseFloat(qualitySlider.value) / 100;
    
    const factors = CONFIG.COMPRESSION_FACTORS[outputFormat];
    if (!factors) return 0.9;
    
    let baseFactor = factors.base;
    
    const sourceFormat = file.type.split('/')[1];
    if (sourceFormat === 'png' && outputFormat !== 'png') {
        baseFactor *= 0.6;
    } else if (sourceFormat === 'jpeg' && outputFormat === 'webp') {
        baseFactor *= 0.8;
    }
    
    const qualityFactor = factors.base + (factors.quality * quality);
    
    return Math.min(baseFactor * qualityFactor, 0.95);
}

function updateSavingsBreakdown(breakdown, totalSavings) {
    const maxSaving = Math.max(breakdown.resize, breakdown.crop, breakdown.compression);
    
    if (breakdown.resize > 0) {
        const percent = maxSaving > 0 ? (breakdown.resize / maxSaving) * 100 : 0;
        resizeSavingsBar.style.width = `${percent}%`;
        resizeSavingsText.textContent = formatFileSize(breakdown.resize);
    } else {
        resizeSavingsBar.style.width = '0%';
        resizeSavingsText.textContent = '-';
    }
    
    if (breakdown.crop > 0) {
        const percent = maxSaving > 0 ? (breakdown.crop / maxSaving) * 100 : 0;
        cropSavingsBar.style.width = `${percent}%`;
        cropSavingsText.textContent = formatFileSize(breakdown.crop);
    } else {
        cropSavingsBar.style.width = '0%';
        cropSavingsText.textContent = '-';
    }
    
    if (breakdown.compression > 0) {
        const percent = maxSaving > 0 ? (breakdown.compression / maxSaving) * 100 : 0;
        compressionSavingsBar.style.width = `${percent}%`;
        compressionSavingsText.textContent = formatFileSize(breakdown.compression);
    } else {
        compressionSavingsBar.style.width = '0%';
        compressionSavingsText.textContent = '-';
    }
}

// --- FONCTIONS D'INTERFACE ---
function updateUI() {
    if (selectedFiles.length > 0) {
        dropzone.classList.add('hidden');
        templatesPanel.classList.remove('hidden');
        imageCount.textContent = selectedFiles.length;
        
        const totalBytes = selectedFiles.reduce((sum, file) => sum + file.size, 0);
        totalSize.textContent = `(${formatFileSize(totalBytes)} total)`;
        
        updatePerformanceEstimate();
        updateProcessButton();
        processTemplateButton.disabled = !selectedTemplate;
    } else {
        dropzone.classList.remove('hidden');
        templatesPanel.classList.add('hidden');
        configPanel.classList.add('hidden');
        resultsPanel.classList.add('hidden');
        hideCropPreview();
    }
}

function updatePerformanceEstimate() {
    if (selectedFiles.length === 0) return;
    
    let estimatedTime = selectedFiles.length * 0.5;
    
    if (enableResize.checked) {
        const scale = parseFloat(resizePercentSlider.value) / 100;
        estimatedTime += selectedFiles.length * 0.2 * (1 / scale);
    }
    
    if (enableCrop.checked) {
        estimatedTime += selectedFiles.length * 0.3;
        if (cropPosition.value === 'intelligent') {
            estimatedTime += selectedFiles.length * 0.5;
        }
    }
    
    if (enableConvert.checked) {
        estimatedTime += selectedFiles.length * 0.4;
    }
    
    if (performanceEstimate) {
        performanceEstimate.textContent = `Temps estim√©: ~${formatTime(estimatedTime * 1000)}`;
    }
}

function updateActionStates() {
    resizeOptions.style.opacity = enableResize.checked ? '1' : '0.5';
    resizeOptions.style.pointerEvents = enableResize.checked ? 'auto' : 'none';
    
    cropOptions.style.opacity = enableCrop.checked ? '1' : '0.5';
    cropOptions.style.pointerEvents = enableCrop.checked ? 'auto' : 'none';
    
    convertOptions.style.opacity = enableConvert.checked ? '1' : '0.5';
    convertOptions.style.pointerEvents = enableConvert.checked ? 'auto' : 'none';
    
    if (enableCrop.checked && (cropPosition.value === 'manual' || cropPosition.value === 'intelligent')) {
        showCropPreview();
    } else {
        hideCropPreview();
    }
    
    if (enableCrop.checked && cropPosition.value === 'intelligent' && !aiDetector.isLoaded) {
        initializeAI();
    }
    
    updateProcessButton();
    updatePerformanceEstimate();
    updateSavingsEstimate();
    updateRecommendations();
}

function updateProcessButton() {
    const hasActions = enableResize.checked || enableCrop.checked || enableConvert.checked;
    if (processButton) {
        processButton.disabled = !hasActions || selectedFiles.length === 0;
    }
}

function showCropPreview() {
    if (selectedFiles.length > 0) {
        cropPreview.classList.remove('hidden');
        
        if (preloadedImage && preloadedImage.file === selectedFiles[0]) {
            previewImage.src = preloadedImage.dataUrl;
            previewImage.onload = () => {
                if (cropPosition.value === 'manual') {
                    initializeCropper();
                } else if (cropPosition.value === 'intelligent') {
                    initializeAIPreview();
                }
            };
        } else {
            const reader = new FileReader();
            reader.onload = (e) => {
                previewImage.src = e.target.result;
                previewImage.onload = () => {
                    if (cropPosition.value === 'manual') {
                        initializeCropper();
                    } else if (cropPosition.value === 'intelligent') {
                        initializeAIPreview();
                    }
                };
            };
            reader.readAsDataURL(selectedFiles[0]);
        }
    }
}

async function initializeAIPreview() {
    if (!aiDetector.isLoaded) {
        await initializeAI();
    }
    
    if (aiDetector.isLoaded && previewImage.complete) {
        try {
            const detections = await aiDetector.detect(previewImage);
            displayDetections(detections, previewImage);
            
            const cropData = aiDetector.calculateIntelligentCrop(
                detections, 
                aspectRatio.value, 
                previewImage.naturalWidth, 
                previewImage.naturalHeight
            );
            
            if (cropData) {
                manualCropData = {
                    x: cropData.x / previewImage.naturalWidth,
                    y: cropData.y / previewImage.naturalHeight,
                    width: cropData.width / previewImage.naturalWidth,
                    height: cropData.height / previewImage.naturalHeight,
                    aspectRatio: cropData.width / cropData.height
                };
                
                showCropOverlay(cropData);
            }
        } catch (error) {
            console.error('Erreur preview IA:', error);
            aiDetectionInfo.innerHTML = '<span class="text-red-600">Erreur de d√©tection IA - utilisation du centre</span>';
            aiDetectionInfo.classList.remove('hidden');
        }
    }
}

function showCropOverlay(cropData) {
    const cropOverlay = document.createElement('div');
    cropOverlay.id = 'cropOverlay';
    cropOverlay.style.position = 'absolute';
    cropOverlay.style.border = '3px dashed #ef4444';
    cropOverlay.style.background = 'rgba(239, 68, 68, 0.1)';
    cropOverlay.style.pointerEvents = 'none';
    cropOverlay.style.borderRadius = '4px';
    
    const imgRect = previewImage.getBoundingClientRect();
    const scaleX = imgRect.width / previewImage.naturalWidth;
    const scaleY = imgRect.height / previewImage.naturalHeight;
    
    cropOverlay.style.left = (cropData.x * scaleX) + 'px';
    cropOverlay.style.top = (cropData.y * scaleY) + 'px';
    cropOverlay.style.width = (cropData.width * scaleX) + 'px';
    cropOverlay.style.height = (cropData.height * scaleY) + 'px';
    
    const label = document.createElement('div');
    label.style.position = 'absolute';
    label.style.top = '-30px';
    label.style.left = '0';
    label.style.background = '#ef4444';
    label.style.color = 'white';
    label.style.padding = '4px 8px';
    label.style.borderRadius = '4px';
    label.style.fontSize = '12px';
    label.style.fontWeight = 'bold';
    label.textContent = 'üìê Zone de recadrage IA';
    cropOverlay.appendChild(label);
    
    const oldOverlay = document.getElementById('cropOverlay');
    if (oldOverlay) oldOverlay.remove();
    
    aiDetectionOverlay.appendChild(cropOverlay);
}

function displayDetections(detections, imageElement) {
    if (!aiDetectionOverlay || !aiDetectionInfo) return;
    
    aiDetectionOverlay.innerHTML = '';
    
    const { faces, objects, recommended } = detections;
    const totalDetections = faces.length + objects.length;
    
    if (totalDetections === 0) {
        aiDetectionInfo.innerHTML = '<span class="text-orange-600">Aucun sujet d√©tect√© - utilisation du centre</span>';
        aiDetectionInfo.classList.remove('hidden');
        return;
    }
    
    const imgRect = imageElement.getBoundingClientRect();
    const scaleX = imgRect.width / imageElement.naturalWidth;
    const scaleY = imgRect.height / imageElement.naturalHeight;
    
    // Afficher les d√©tections de visages
    faces.forEach((face, index) => {
        const div = document.createElement('div');
        div.className = 'ai-detection-box ai-detection-face';
        div.style.left = (face.bbox[0] * scaleX) + 'px';
        div.style.top = (face.bbox[1] * scaleY) + 'px';
        div.style.width = (face.bbox[2] * scaleX) + 'px';
        div.style.height = (face.bbox[3] * scaleY) + 'px';
        
        const label = document.createElement('div');
        label.className = 'ai-detection-label';
        label.textContent = `Visage ${Math.round(face.confidence * 100)}%`;
        div.appendChild(label);
        
        aiDetectionOverlay.appendChild(div);
    });
    
    // Afficher les d√©tections d'objets
    objects.forEach((obj, index) => {
        const div = document.createElement('div');
        div.className = `ai-detection-box ai-detection-${obj.class === 'person' ? 'person' : 'object'}`;
        div.style.left = (obj.bbox[0] * scaleX) + 'px';
        div.style.top = (obj.bbox[1] * scaleY) + 'px';
        div.style.width = (obj.bbox[2] * scaleX) + 'px';
        div.style.height = (obj.bbox[3] * scaleY) + 'px';
        
        const label = document.createElement('div');
        label.className = 'ai-detection-label';
        label.textContent = `${obj.class} ${Math.round(obj.confidence * 100)}%`;
        div.appendChild(label);
        
        aiDetectionOverlay.appendChild(div);
    });
    
    // Marquer le sujet principal
    if (recommended) {
        const mainDiv = document.createElement('div');
        mainDiv.className = 'ai-detection-box';
        mainDiv.style.left = (recommended.bbox[0] * scaleX) + 'px';
        mainDiv.style.top = (recommended.bbox[1] * scaleY) + 'px';
        mainDiv.style.width = (recommended.bbox[2] * scaleX) + 'px';
        mainDiv.style.height = (recommended.bbox[3] * scaleY) + 'px';
        mainDiv.style.borderColor = '#ef4444';
        mainDiv.style.borderWidth = '3px';
        mainDiv.style.background = 'rgba(239, 68, 68, 0.2)';
        
        const mainLabel = document.createElement('div');
        mainLabel.className = 'ai-detection-label';
        mainLabel.style.background = '#ef4444';
        mainLabel.textContent = 'üéØ Sujet principal';
        mainDiv.appendChild(mainLabel);
        
        aiDetectionOverlay.appendChild(mainDiv);
    }
    
    const subjectType = recommended ? (recommended.type === 'face' ? 'visage' : recommended.class || 'objet') : 'aucun';
    aiDetectionInfo.innerHTML = `
        <span class="text-green-600">‚úì ${totalDetections} d√©tection(s)</span> ‚Ä¢ 
        <span class="text-blue-600">Sujet principal: ${subjectType}</span>
    `;
    aiDetectionInfo.classList.remove('hidden');
    aiDetectionOverlay.classList.remove('hidden');
}

function initializeCropper() {
    if (cropperInstance) {
        cropperInstance.destroy();
    }
    
    const ratio = parseAspectRatio(aspectRatio.value);
    cropperInstance = new Cropper(previewImage, {
        aspectRatio: ratio,
        viewMode: 1,
        autoCropArea: 0.8,
        guides: true,
        highlight: true,
        movable: true,
        zoomable: true,
        rotatable: false,
        scalable: false,
        responsive: true,
        checkOrientation: false,
        ready() {
            const containerData = cropperInstance.getContainerData();
            cropperInstance.setCropBoxData({
                width: Math.min(containerData.width * 0.8, 800),
                height: Math.min(containerData.height * 0.8, 600)
            });
        },
        crop: (event) => {
            const { x, y, width, height } = event.detail;
            const { naturalWidth, naturalHeight } = previewImage;
            
            manualCropData = {
                x: x / naturalWidth,
                y: y / naturalHeight,
                width: width / naturalWidth,
                height: height / naturalHeight,
                aspectRatio: width / height
            };
            
            updateSavingsEstimate();
        }
    });
    
    aiDetectionOverlay.classList.add('hidden');
    aiDetectionInfo.classList.add('hidden');
}

function updateCropperAspectRatio() {
    if (cropperInstance) {
        const ratio = parseAspectRatio(aspectRatio.value);
        cropperInstance.setAspectRatio(ratio);
    }
}

function hideCropPreview() {
    cropPreview.classList.add('hidden');
    if (cropperInstance) {
        cropperInstance.destroy();
        cropperInstance = null;
    }
    manualCropData = null;
    
    if (aiDetectionOverlay) {
        aiDetectionOverlay.innerHTML = '';
        aiDetectionOverlay.classList.add('hidden');
    }
    if (aiDetectionInfo) {
        aiDetectionInfo.classList.add('hidden');
    }
}

// --- TRAITEMENT DES IMAGES ---
async function processImages() {
    if (selectedFiles.length === 0) return;
    
    startTime = Date.now();
    realTimeSavingsTotal = 0;
    abortController = new AbortController();
    
    templatesPanel.classList.add('hidden');
    configPanel.classList.add('hidden');
    progressPanel.classList.remove('hidden');
    progressPanel.scrollIntoView({ behavior: 'smooth' });
    
    errorsList.classList.add('hidden');
    errorsContent.innerHTML = '';
    
    const processedBlobs = [];
    const errors = [];
    const total = selectedFiles.length;
    
    // Initialiser l'IA si n√©cessaire
    if (enableCrop.checked && cropPosition.value === 'intelligent' && !aiDetector.isLoaded) {
        updateProgress(0, total, 'Chargement de l\'IA...');
        await initializeAI();
    }
    
    try {
        for (let i = 0; i < selectedFiles.length; i += CONFIG.CHUNK_SIZE) {
            if (abortController.signal.aborted) {
                throw new Error('Traitement annul√©');
            }
            
            const chunk = selectedFiles.slice(i, i + CONFIG.CHUNK_SIZE);
            const chunkResults = await Promise.all(
                chunk.map(async (file, index) => {
                    const globalIndex = i + index;
                    updateProgress(globalIndex, total, `Traitement de ${file.name}...`);
                    
                    try {
                        const result = await processImage(file, globalIndex);
                        
                        const savings = file.size - result.blob.size;
                        realTimeSavingsTotal += savings;
                        updateRealTimeSavings();
                        
                        return {
                            success: true,
                            blob: result.blob,
                            name: generateIntelligentFileName(file.name, globalIndex),
                            originalSize: file.size,
                            newSize: result.blob.size
                        };
                    } catch (error) {
                        console.error(`Erreur lors du traitement de ${file.name}:`, error);
                        return {
                            success: false,
                            error: { file: file.name, message: error.message }
                        };
                    }
                })
            );
            
            chunkResults.forEach(result => {
                if (result.success) {
                    processedBlobs.push({ 
                        blob: result.blob, 
                        name: result.name,
                        originalSize: result.originalSize,
                        newSize: result.newSize
                    });
                } else {
                    errors.push(result.error);
                }
            });
        }
        
        if (errors.length > 0) {
            showErrorSummary(errors);
        }
        
        updateProgress(total, total, 'G√©n√©ration du t√©l√©chargement...');
        
        if (processedBlobs.length === 1) {
            downloadBlob(processedBlobs[0].blob, processedBlobs[0].name);
        } else if (processedBlobs.length > 1) {
            await downloadZip(processedBlobs);
        }
        
        const totalOriginalSize = processedBlobs.reduce((sum, item) => sum + item.originalSize, 0);
        const totalNewSize = processedBlobs.reduce((sum, item) => sum + item.newSize, 0);
        const finalSavings = totalOriginalSize - totalNewSize;
        const savingsPercent = ((finalSavings / totalOriginalSize) * 100).toFixed(1);
        
        finalResults = {
            processedCount: processedBlobs.length,
            originalSize: totalOriginalSize,
            newSize: totalNewSize,
            savings: finalSavings,
            savingsPercent: savingsPercent,
            carbonSaved: (finalSavings / (1024 * 1024)) * CONFIG.CO2_FACTOR_PER_MB,
            template: selectedTemplate,
            processingTime: Date.now() - startTime,
            errors: errors,
            usedAI: enableCrop.checked && cropPosition.value === 'intelligent'
        };
        
        showResults();
        
    } catch (error) {
        if (error.message === 'Traitement annul√©') {
            showMessage('Traitement annul√© par l\'utilisateur', 'warning');
            resetAll();
        } else {
            showMessage(`Erreur: ${error.message}`, 'error');
            resetAll();
        }
    } finally {
        imageCache.clear();
        aiDetectionCache.clear();
    }
}

function updateRealTimeSavings() {
    currentSavings.textContent = `${formatFileSize(realTimeSavingsTotal)} √©conomis√©s`;
}

function generateIntelligentFileName(originalName, index) {
    const baseName = originalName.replace(/\.[^/.]+$/, '');
    let extension = 'webp';
    let suffix = '';
    
    if (enableConvert.checked) {
        extension = document.getElementById('outputFormat').value;
        if (extension === 'jpeg') extension = 'jpg';
    } else {
        extension = originalName.split('.').pop().toLowerCase();
    }
    
    if (selectedTemplate) {
        const template = CONFIG.TEMPLATES[selectedTemplate];
        suffix = template.suffix || '';
        
        if (selectedTemplate === 'instagram' && template.multiFormat) {
            suffix = template.multiFormat[0].suffix;
        }
    } else {
        const actions = [];
        if (enableResize.checked) actions.push(`${resizePercentSlider.value}pct`);
        if (enableCrop.checked) {
            actions.push(aspectRatio.value.replace('/', 'x'));
            if (cropPosition.value === 'intelligent') actions.push('ai');
        }
        if (enableConvert.checked) actions.push(extension);
        
        suffix = actions.length > 0 ? `_${actions.join('_')}` : '_optimized';
    }
    
    let dimensions = '';
    if (enableCrop.checked) {
        const ratio = aspectRatio.value;
        if (ratio === '1/1') dimensions = '_1080x1080';
        else if (ratio === '16/9') dimensions = '_1920x1080';
        else if (ratio === '9/16') dimensions = '_1080x1920';
        else if (ratio === '4/3') dimensions = '_1200x900';
        else if (ratio === '3/4') dimensions = '_900x1200';
    }
    
    return `${baseName}${suffix}${dimensions}.${extension}`;
}

async function processImage(file, index) {
    return new Promise(async (resolve, reject) => {
        const img = new Image();
        const objectUrl = URL.createObjectURL(file);
        
        img.onload = async () => {
            try {
                let width = img.naturalWidth;
                let height = img.naturalHeight;
                
                if (width > CONFIG.MAX_DIMENSION || height > CONFIG.MAX_DIMENSION) {
                    const scale = Math.min(CONFIG.MAX_DIMENSION / width, CONFIG.MAX_DIMENSION / height);
                    width = Math.round(width * scale);
                    height = Math.round(height * scale);
                    showMessage(`${file.name} redimensionn√©e pour optimiser les performances`, 'info');
                }
                
                let canvas;
                if (typeof OffscreenCanvas !== 'undefined') {
                    canvas = new OffscreenCanvas(width, height);
                } else {
                    canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                }
                
                let ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(img, 0, 0, width, height);
                
                if (enableCrop.checked) {
                    canvas = await applyCrop(canvas, img, index);
                }
                
                if (enableResize.checked) {
                    canvas = await applyResize(canvas);
                }
                
                if (enableConvert.checked) {
                    const format = document.getElementById('outputFormat').value;
                    const quality = parseFloat(qualitySlider.value) / 100;
                    
                    await convertWithOptimizedQuality(canvas, format, quality, (blob) => {
                        resolve({ blob });
                    });
                } else {
                    const quality = file.type === 'image/png' ? 1 : 0.95;
                    canvas.toBlob((blob) => {
                        resolve({ blob });
                    }, file.type, quality);
                }
            } catch (error) {
                reject(error);
            } finally {
                URL.revokeObjectURL(objectUrl);
            }
        };
        
        img.onerror = () => {
            URL.revokeObjectURL(objectUrl);
            reject(new Error('Impossible de charger l\'image'));
        };
        
        img.src = objectUrl;
    });
}

async function applyResize(canvas) {
    const percent = parseFloat(resizePercentSlider.value) / 100;
    const newWidth = Math.round(canvas.width * percent);
    const newHeight = Math.round(canvas.height * percent);
    
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    
    tempCanvas.width = newWidth;
    tempCanvas.height = newHeight;
    tempCtx.imageSmoothingEnabled = true;
    tempCtx.imageSmoothingQuality = 'high';
    tempCtx.drawImage(canvas, 0, 0, newWidth, newHeight);
    
    return tempCanvas;
}

async function applyCrop(canvas, originalImg, imageIndex = 0) {
    const position = cropPosition.value;
    const aspectRatioStr = aspectRatio.value;
    
    let cropData;
    
    if (position === 'intelligent') {
        try {
            let detections = aiDetectionCache.get(originalImg.src);
            
            if (!detections) {
                const tempImg = document.createElement('img');
                tempImg.src = originalImg.src;
                await new Promise(resolve => {
                    tempImg.onload = resolve;
                });
                
                detections = await aiDetector.detect(tempImg);
                aiDetectionCache.set(originalImg.src, detections);
            }
            
            cropData = aiDetector.calculateIntelligentCrop(detections, aspectRatioStr, canvas.width, canvas.height);
            
            if (!cropData) {
                cropData = calculateCenterCrop(aspectRatioStr, canvas.width, canvas.height);
            }
        } catch (error) {
            console.error('Erreur crop IA:', error);
            cropData = calculateCenterCrop(aspectRatioStr, canvas.width, canvas.height);
        }
    } else if (position === 'manual' && manualCropData) {
        cropData = {
            x: manualCropData.x * canvas.width,
            y: manualCropData.y * canvas.height,
            width: manualCropData.width * canvas.width,
            height: manualCropData.height * canvas.height
        };
    } else {
        const targetRatio = parseAspectRatio(aspectRatioStr);
        
        if (isNaN(targetRatio)) {
            return canvas;
        }
        
        const currentRatio = canvas.width / canvas.height;
        let cropWidth, cropHeight, cropX, cropY;
        
        if (currentRatio > targetRatio) {
            cropHeight = canvas.height;
            cropWidth = cropHeight * targetRatio;
            cropY = 0;
            
            switch (position) {
                case 'left': cropX = 0; break;
                case 'right': cropX = canvas.width - cropWidth; break;
                default: cropX = (canvas.width - cropWidth) / 2; break;
            }
        } else {
            cropWidth = canvas.width;
            cropHeight = cropWidth / targetRatio;
            cropX = 0;
            
            switch (position) {
                case 'top': cropY = 0; break;
                case 'bottom': cropY = canvas.height - cropHeight; break;
                default: cropY = (canvas.height - cropHeight) / 2; break;
            }
        }
        
        cropData = { x: cropX, y: cropY, width: cropWidth, height: cropHeight };
    }
    
    if (!cropData) return canvas;
    
    cropData.x = Math.max(0, Math.min(cropData.x, canvas.width - 1));
    cropData.y = Math.max(0, Math.min(cropData.y, canvas.height - 1));
    cropData.width = Math.min(cropData.width, canvas.width - cropData.x);
    cropData.height = Math.min(cropData.height, canvas.height - cropData.y);
    
    if (cropData.width <= 0 || cropData.height <= 0) {
        console.warn('Dimensions de recadrage invalides, retour √† l\'image originale');
        return canvas;
    }
    
    const newCanvas = document.createElement('canvas');
    newCanvas.width = Math.round(cropData.width);
    newCanvas.height = Math.round(cropData.height);
    const ctx = newCanvas.getContext('2d');
    
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    
    ctx.drawImage(
        canvas,
        Math.round(cropData.x), Math.round(cropData.y),
        Math.round(cropData.width), Math.round(cropData.height),
        0, 0,
        Math.round(cropData.width), Math.round(cropData.height)
    );
    
    return newCanvas;
}

function calculateCenterCrop(targetAspectRatio, canvasWidth, canvasHeight) {
    const targetRatio = parseAspectRatio(targetAspectRatio);
    if (isNaN(targetRatio)) return null;
    
    const currentRatio = canvasWidth / canvasHeight;
    let cropWidth, cropHeight, cropX, cropY;
    
    if (currentRatio > targetRatio) {
        cropHeight = canvasHeight;
        cropWidth = cropHeight * targetRatio;
        cropY = 0;
        cropX = (canvasWidth - cropWidth) / 2;
    } else {
        cropWidth = canvasWidth;
        cropHeight = cropWidth / targetRatio;
        cropX = 0;
        cropY = (canvasHeight - cropHeight) / 2;
    }
    
    return { x: cropX, y: cropY, width: cropWidth, height: cropHeight };
}

async function convertWithOptimizedQuality(canvas, format, quality, resolve) {
    const mimeType = format === 'png' ? 'image/png' : `image/${format}`;
    
    if (format === 'webp') {
        const optimizedQuality = Math.max(0.8, quality);
        canvas.toBlob(resolve, mimeType, optimizedQuality);
    } else if (format === 'jpeg') {
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
        if (canvas.width * canvas.height < 4000000) {
            applySharpenFilter(imageData);
            ctx.putImageData(imageData, 0, 0);
        }
        
        const optimizedQuality = Math.max(0.85, quality);
        canvas.toBlob(resolve, mimeType, optimizedQuality);
    } else {
        canvas.toBlob(resolve, mimeType, 1);
    }
}

function applySharpenFilter(imageData) {
    const data = imageData.data;
    const width = imageData.width;
    const height = imageData.height;
    const newData = new Uint8ClampedArray(data);
    
    const kernel = [
        0, -0.25, 0,
        -0.25, 2, -0.25,
        0, -0.25, 0
    ];
    
    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            for (let c = 0; c < 3; c++) {
                let sum = 0;
                for (let ky = -1; ky <= 1; ky++) {
                    for (let kx = -1; kx <= 1; kx++) {
                        const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                        sum += data[idx] * kernel[(ky + 1) * 3 + (kx + 1)];
                    }
                }
                const idx = (y * width + x) * 4 + c;
                newData[idx] = Math.max(0, Math.min(255, sum));
            }
        }
    }
    
    for (let i = 0; i < data.length; i += 4) {
        for (let c = 0; c < 3; c++) {
            data[i + c] = Math.round(data[i + c] * 0.8 + newData[i + c] * 0.2);
        }
    }
}

// --- FONCTIONS DE R√âSULTATS ---
function showResults() {
    progressPanel.classList.add('hidden');
    resultsPanel.classList.remove('hidden');
    resultsPanel.scrollIntoView({ behavior: 'smooth' });
    
    document.getElementById('finalImagesProcessed').textContent = finalResults.processedCount;
    document.getElementById('finalSavingsAmount').textContent = formatFileSize(finalResults.savings);
    document.getElementById('finalSavingsPercent').textContent = finalResults.savingsPercent + '%';
    document.getElementById('finalCarbonSaved').textContent = finalResults.carbonSaved.toFixed(1) + 'g';
    
    const processingDetails = document.getElementById('processingDetails');
    let detailsHTML = '';
    
    if (selectedTemplate) {
        detailsHTML += `<div>‚Ä¢ Template utilis√©: ${CONFIG.TEMPLATES[selectedTemplate].name}</div>`;
    }
    
    if (enableResize.checked) {
        detailsHTML += `<div>‚Ä¢ Redimensionnement: ${resizePercentSlider.value}%</div>`;
    }
    
    if (enableCrop.checked) {
        const cropMethod = cropPosition.value === 'intelligent' ? 'ü§ñ IA' : cropPosition.value;
        detailsHTML += `<div>‚Ä¢ Recadrage: ${aspectRatio.value} (${cropMethod})</div>`;
    }
    
    if (enableConvert.checked) {
        detailsHTML += `<div>‚Ä¢ Conversion: ${document.getElementById('outputFormat').value.toUpperCase()} (${qualitySlider.value}%)</div>`;
    }
    
    if (finalResults.usedAI) {
        detailsHTML += `<div class="text-blue-600">‚Ä¢ ü§ñ IA utilis√©e pour la d√©tection de sujets</div>`;
    }
    
    detailsHTML += `<div>‚Ä¢ Temps de traitement: ${formatTime(finalResults.processingTime)}</div>`;
    
    if (finalResults.errors.length > 0) {
        detailsHTML += `<div class="text-red-600">‚Ä¢ ${finalResults.errors.length} erreur(s) rencontr√©e(s)</div>`;
    }
    
    processingDetails.innerHTML = detailsHTML;
    
    const environmentalDetails = document.getElementById('environmentalDetails');
    const mbSaved = finalResults.savings / (1024 * 1024);
    const minutesStreaming = (mbSaved * 0.1).toFixed(1);
    const kmCar = (mbSaved * 0.0001).toFixed(2);
    
    environmentalDetails.innerHTML = `
        <div>Cette optimisation √©conomise ${finalResults.carbonSaved.toFixed(1)}g de CO‚ÇÇ en transferts r√©seau.</div>
        <div class="mt-2 text-sm">√âquivalences:</div>
        <div class="text-sm">‚Ä¢ ${minutesStreaming} minutes de streaming vid√©o √©vit√©es</div>
        <div class="text-sm">‚Ä¢ ${kmCar} km en voiture √©conomis√©s</div>
    `;
}

function downloadReport() {
    const report = generateTextReport();
    const blob = new Blob([report], { type: 'text/plain;charset=utf-8' });
    downloadBlob(blob, `rapport_optimisation_ai_${new Date().getTime()}.txt`);
}

function generateTextReport() {
    const date = new Date().toLocaleString();
    let report = `RAPPORT D'OPTIMISATION D'IMAGES AVEC IA\n`;
    report += `G√©n√©r√© le: ${date}\n\n`;
    
    report += `STATISTIQUES GLOBALES\n`;
    report += `=====================\n`;
    report += `Images trait√©es: ${finalResults.processedCount}\n`;
    report += `Taille originale: ${formatFileSize(finalResults.originalSize)}\n`;
    report += `Taille finale: ${formatFileSize(finalResults.newSize)}\n`;
    report += `√âconomies: ${formatFileSize(finalResults.savings)} (${finalResults.savingsPercent}%)\n`;
    report += `CO‚ÇÇ √©conomis√©: ${finalResults.carbonSaved.toFixed(1)}g\n`;
    report += `Temps de traitement: ${formatTime(finalResults.processingTime)}\n`;
    if (finalResults.usedAI) {
        report += `IA utilis√©e: Oui (d√©tection automatique de sujets)\n`;
    }
    report += `\n`;
    
    report += `CONFIGURATION UTILIS√âE\n`;
    report += `======================\n`;
    if (selectedTemplate) {
        report += `Template: ${CONFIG.TEMPLATES[selectedTemplate].name}\n`;
    }
    if (enableResize.checked) {
        report += `Redimensionnement: ${resizePercentSlider.value}%\n`;
    }
    if (enableCrop.checked) {
        const cropMethod = cropPosition.value === 'intelligent' ? 'IA (d√©tection automatique)' : cropPosition.value;
        report += `Recadrage: ${aspectRatio.value} (m√©thode: ${cropMethod})\n`;
    }
    if (enableConvert.checked) {
        report += `Conversion: ${document.getElementById('outputFormat').value.toUpperCase()} (qualit√©: ${qualitySlider.value}%)\n`;
    }
    
    if (finalResults.errors.length > 0) {
        report += `\nERREURS RENCONTR√âES\n`;
        report += `===================\n`;
        finalResults.errors.forEach(error => {
            report += `‚Ä¢ ${error.file}: ${error.message}\n`;
        });
    }
    
    return report;
}

// --- FONCTIONS UTILITAIRES (SUITE) ---
function updateProgress(current, total, text) {
    const percent = Math.round((current / total) * 100);
    progressBar.style.width = percent + '%';
    progressText.textContent = text;
    progressPercent.textContent = percent + '%';
    
    if (startTime && current > 0) {
        const elapsed = Date.now() - startTime;
        const timePerItem = elapsed / current;
        const remaining = timePerItem * (total - current);
        timeRemaining.textContent = `Temps restant: ${formatTime(remaining)}`;
    }
}

function downloadBlob(blob, filename) {
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
    
    setTimeout(() => URL.revokeObjectURL(link.href), 100);
}

async function downloadZip(processedBlobs) {
    const zip = new JSZip();
    
    for (const { blob, name } of processedBlobs) {
        zip.file(name, blob);
    }
    
    const zipBlob = await zip.generateAsync({ 
        type: 'blob',
        compression: 'DEFLATE',
        compressionOptions: { level: 6 }
    });
    
    downloadBlob(zipBlob, 'images_optimized_ai.zip');
}

function showErrorSummary(errors) {
    if (errors.length === 0) return;
    
    errorsList.classList.remove('hidden');
    errorsContent.innerHTML = '';
    
    errors.forEach(error => {
        const li = document.createElement('li');
        li.textContent = `${error.file}: ${error.message}`;
        errorsContent.appendChild(li);
    });
    
    showMessage(`${errors.length} erreur(s) rencontr√©e(s)`, 'error');
}

function cancelProcessing() {
    if (abortController) {
        abortController.abort();
    }
}

function resetAll() {
    selectedFiles = [];
    manualCropData = null;
    preloadedImage = null;
    imageCache.clear();
    aiDetectionCache.clear();
    realTimeSavingsTotal = 0;
    selectedTemplate = null;
    finalResults = null;
    hideCropPreview();
    
    document.querySelectorAll('.template-card').forEach(c => c.classList.remove('selected'));
    processTemplateButton.disabled = true;
    
    document.querySelectorAll('.action-checkbox').forEach(cb => cb.checked = false);
    
    resizePercentSlider.value = 80;
    resizePercentValue.textContent = '80%';
    qualitySlider.value = 90;
    qualityValue.textContent = '90%';
    
    cropPosition.value = 'intelligent';
    aspectRatio.value = '1/1';
    document.getElementById('outputFormat').value = 'webp';
    
    updateActionStates();
    
    templatesPanel.classList.add('hidden');
    configPanel.classList.add('hidden');
    progressPanel.classList.add('hidden');
    resultsPanel.classList.add('hidden');
    aiLoadingPanel.classList.add('hidden');
    dropzone.classList.remove('hidden');
    
    dropzone.scrollIntoView({ behavior: 'smooth' });
    
    progressBar.style.width = '0%';
    progressText.textContent = 'Initialisation...';
    progressPercent.textContent = '0%';
    timeRemaining.textContent = '';
    
    if (currentSavings) {
        currentSavings.textContent = '0 MB √©conomis√©s';
    }
    
    errorsList.classList.add('hidden');
    errorsContent.innerHTML = '';
    
    if (abortController) {
        abortController.abort();
        abortController = null;
    }
    
    recommendationsList.innerHTML = '<p class="text-gray-600">S√©lectionnez des images pour voir les recommandations...</p>';
}

// --- EVENT LISTENERS ---
dropzone.addEventListener('click', () => fileInput.click());
dropzone.addEventListener('dragover', handleDragOver);
dropzone.addEventListener('dragleave', handleDragLeave);
dropzone.addEventListener('drop', handleDrop);
fileInput.addEventListener('change', handleFileSelect);

manualConfigBtn.addEventListener('click', () => {
    templatesPanel.classList.add('hidden');
    configPanel.classList.remove('hidden');
    configPanel.scrollIntoView({ behavior: 'smooth' });
});

backToTemplatesBtn.addEventListener('click', () => {
    configPanel.classList.add('hidden');
    templatesPanel.classList.remove('hidden');
    templatesPanel.scrollIntoView({ behavior: 'smooth' });
});

newProcessingBtn.addEventListener('click', () => {
    resetAll();
});

downloadResultsBtn.addEventListener('click', () => {
    downloadReport();
});

document.querySelectorAll('.template-card').forEach(card => {
    card.addEventListener('click', () => {
        document.querySelectorAll('.template-card').forEach(c => c.classList.remove('selected'));
        card.classList.add('selected');
        selectedTemplate = card.dataset.template;
        processTemplateButton.disabled = false;
        
        applyTemplate(selectedTemplate);
        updateSavingsEstimate();
        updateRecommendations();
    });
});

processTemplateButton.addEventListener('click', () => {
    if (selectedTemplate) {
        applyTemplate(selectedTemplate);
        processImages();
    }
});

document.querySelectorAll('.action-checkbox').forEach(checkbox => {
    checkbox.addEventListener('change', updateActionStates);
});

resizePercentSlider.addEventListener('input', () => {
    resizePercentValue.textContent = resizePercentSlider.value + '%';
    updatePerformanceEstimate();
    updateSavingsEstimate();
    updateRecommendations();
});

qualitySlider.addEventListener('input', () => {
    qualityValue.textContent = qualitySlider.value + '%';
    updateSavingsEstimate();
    updateRecommendations();
});

document.getElementById('outputFormat').addEventListener('change', () => {
    updateSavingsEstimate();
    updateRecommendations();
});

aspectRatio.addEventListener('change', () => {
    updateSavingsEstimate();
    updateRecommendations();
    if (enableCrop.checked && cropPosition.value === 'manual' && cropperInstance) {
        updateCropperAspectRatio();
    }
});

cropPosition.addEventListener('change', () => {
    if (enableCrop.checked && (cropPosition.value === 'manual' || cropPosition.value === 'intelligent')) {
        showCropPreview();
    } else {
        hideCropPreview();
    }
    updateSavingsEstimate();
});

processButton.addEventListener('click', processImages);
resetButton.addEventListener('click', resetAll);
cancelButton.addEventListener('click', cancelProcessing);

// --- INITIALISATION ---
async function initializeApp() {
    const dependenciesLoaded = await loadDependencies();
    
    if (!dependenciesLoaded) {
        showMessage('Certaines fonctionnalit√©s ne sont pas disponibles', 'warning');
        cropPosition.value = 'center';
    } else {
        cropPosition.value = 'intelligent';
        
        // Pr√©charger les mod√®les IA en arri√®re-plan
        setTimeout(() => {
            initializeAI();
        }, 2000);
    }
    
    updateActionStates();
    processTemplateButton.disabled = true;
    
    console.log('ü§ñ Processeur d\'images intelligent avec IA initialis√© !');
}

window.addEventListener('beforeunload', () => {
    imageCache.clear();
    if (aiDetectionCache) aiDetectionCache.clear();
    if (cropperInstance) {
        cropperInstance.destroy();
    }
});

// Initialiser au chargement
document.addEventListener('DOMContentLoaded', initializeApp);
</script>