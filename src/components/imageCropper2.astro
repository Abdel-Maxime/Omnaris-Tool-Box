---
/* On importe uniquement la feuille de style Cropper ici, au build time */
import 'cropperjs/dist/cropper.css';
---

<section class="max-w-xl mx-auto p-6 space-y-6">
    <!-- Zone d'upload (visible tant que files.length === 0) -->
    <div
            id="dropzone"
            class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer transition-colors hover:border-gray-500"
    >
        <p class="text-gray-500">
            Glissez-déposez des images ici, ou cliquez pour sélectionner
        </p>
        <input
                type="file"
                accept="image/*"
                id="fileInput"
                class="hidden"
                multiple
        />
    </div>

    <!-- Container de preview + contrôles (caché tant que files.length === 0) -->
    <div
            id="previewContainer"
            class="hidden flex-col items-center space-y-4"
    >
        <!-- Sélecteur de format -->
        <div class="w-full h-12 flex justify-center items-center gap-6 my-4">
            <label for="aspectRatioSelector" class="mr-2 font-medium text-gray-700">Choisissez un format :</label>
            <select
                    id="aspectRatioSelector"
                    class="border border-gray-300 rounded-md px-3 py-2 bg-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
            >
                <!-- Les valeurs sont des string "largeur/hauteur" pour être calculées en JS -->
                <option value="1/1">1:1 (Carré)</option>
                <option value="16/9">16:9 (Paysage)</option>
                <option value="4/5">4:5 (Portrait)</option>
                <option value="9/16">9:16 (Portrait mobile)</option>
            </select>
        </div>

        <!-- Image en cours de recadrage -->
        <div class="w-full overflow-hidden max-h-[80vh]">
            <img
                    id="imagePreview"
                    src=""
                    alt="Image à recadrer"
                    class="max-w-full max-h-full rounded-lg mx-auto"
            />
        </div>

        <!-- Boutons de navigation / suppression -->
        <div class="flex space-x-2">
            <button
                    id="deleteButton"
                    class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-md"
            >
                Supprimer cette image
            </button>
            <button
                    id="cropNextButton"
                    class="bg-primary hover:bg-secondary text-white font-semibold py-2 px-4 rounded-md"
            >
                Recadrer &amp; Suivant
            </button>
        </div>
    </div>
</section>

<!--
  Tout le code JS qui manipule le DOM, instancie Cropper & JSZip
  doit être placé dans un <script client:load> pour s'assurer que ça s'exécute uniquement dans le navigateur,
  une fois le DOM monté.
-->
<script>
    import Cropper from 'cropperjs';
    import JSZip from 'jszip';

    // --- RÉFÉRENCES AU DOM ---
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const previewContainer = document.getElementById('previewContainer');
    const aspectRatioSelector = document.getElementById('aspectRatioSelector');
    const imagePreview = document.getElementById('imagePreview');
    const cropNextButton = document.getElementById('cropNextButton');
    const deleteButton = document.getElementById('deleteButton');

    // --- ÉTAT GLOBAL ---
    let files = [];          // Tableau des fichiers sélectionnés
    let currentIndex = 0;    // Index de l'image active
    let cropperInstance = null;
    let croppedBlobs = [];   // Stocke les blobs WebP recadrés

    // 1) Cliquer sur la zone pour ouvrir le file picker
    dropzone.addEventListener('click', () => {
        fileInput.click();
    });

    // 2) Gérer le drag & drop
    dropzone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropzone.classList.add('border-gray-500', 'bg-gray-50');
    });
    dropzone.addEventListener('dragleave', (e) => {
        e.preventDefault();
        dropzone.classList.remove('border-gray-500', 'bg-gray-50');
    });
    dropzone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropzone.classList.remove('border-gray-500', 'bg-gray-50');
        const dt = e.dataTransfer;
        if (dt.files && dt.files.length) {
            handleFiles(dt.files);
        }
    });

    // 3) Quand l’utilisateur choisit des fichiers via l’input (multiple possible)
    fileInput.addEventListener('change', (e) => {
        if (e.target.files && e.target.files.length) {
            handleFiles(e.target.files);
            // Réinitialiser la valeur pour pouvoir resélectionner les mêmes fichiers plus tard
            fileInput.value = '';
        }
    });

    // 4) Changement de format (aspect ratio)
    aspectRatioSelector.addEventListener('change', () => {
        if (cropperInstance) {
            const newRatio = parseRatio(aspectRatioSelector.value);
            cropperInstance.setAspectRatio(newRatio);
        }
    });

    // --- Fonction utilitaire pour convertir "w/h" en nombre ---
    function parseRatio(ratioStr) {
        const [w, h] = ratioStr.split('/').map(Number);
        return h > 0 ? w / h : 1;
    }

    // --- Fonction pour traiter un FileList ou tableau de File ---
    function handleFiles(fileList) {
        const newFiles = Array.from(fileList);
        files = files.concat(newFiles);

        // Masquer la dropzone et afficher le container de preview si au moins 1 image
        if (files.length > 0) {
            dropzone.classList.add('hidden');
            previewContainer.classList.remove('hidden');
            // Faire défiler vers la zone d’édition pour que l’utilisateur voie immédiatement
            previewContainer.scrollIntoView({ behavior: 'smooth' });
        }

        // Si on partait sans aucune image, on initialise le recadrage au premier élément
        if (files.length === newFiles.length) {
            currentIndex = 0;
            croppedBlobs = [];
            loadImageAtIndex(currentIndex);
        }
    }

    // --- Charger l'image à l'index donné, la redimensionner si nécessaire, puis initier Cropper ---
    function loadImageAtIndex(index) {
        // Détruire Cropper existant s’il existe
        if (cropperInstance) {
            cropperInstance.destroy();
            cropperInstance = null;
        }

        // Lire le fichier via FileReader
        const reader = new FileReader();
        reader.onload = (evt) => {
            const originalDataURL = evt.target.result;
            imagePreview.src = originalDataURL;

            // Une fois l’image chargée dans le <img>
            imagePreview.onload = () => {
                const naturalW = imagePreview.naturalWidth;

                // Si largeur > 2000px, on redimensionne à 30% avant d'initialiser Cropper
                if (naturalW > 2000) {
                    const targetW = Math.round(naturalW * 0.3);
                    const targetH = Math.round(imagePreview.naturalHeight * 0.3);

                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = targetW;
                    tempCanvas.height = targetH;
                    const ctx = tempCanvas.getContext('2d');
                    ctx.drawImage(imagePreview, 0, 0, targetW, targetH);

                    // On récupère un Blob JPEG (qualité 1.0) pour recréer un DataURL optimisé
                    tempCanvas.toBlob(
                        (blob) => {
                            const resizedURL = URL.createObjectURL(blob);
                            // On met à jour l'imagePreview avec la version redimensionnée
                            imagePreview.src = resizedURL;

                            imagePreview.onload = () => {
                                // Dès que la version redimensionnée est chargée, on initialise Cropper
                                initializeCropper(index);
                                // On peut révoquer l'URL une fois utilisé
                                URL.revokeObjectURL(resizedURL);
                            };
                        },
                        'image/jpeg',
                        1.0
                    );
                } else {
                    // Si pas besoin de redimension, on init directement Cropper
                    initializeCropper(index);
                }
            };
        };
        reader.readAsDataURL(files[index]);
    }

    // --- Initialisation de Cropper et mise à jour du libellé du bouton ---
    function initializeCropper(index) {
        const initialRatio = parseRatio(aspectRatioSelector.value);

        cropperInstance = new Cropper(imagePreview, {
            aspectRatio: initialRatio,
            viewMode: 1,
            autoCropArea: 1,
            guides: true,
            highlight: true,
            movable: true,
            zoomable: true,
            rotatable: false,
            scalable: false,
        });

        // Mise à jour du texte du bouton selon l'index et le nombre total
        if (files.length > 1) {
            cropNextButton.textContent =
                index < files.length - 1
                    ? 'Recadrer & Suivant'
                    : 'Recadrer & Télécharger';
        } else {
            cropNextButton.textContent = 'Recadrer & Télécharger';
        }
    }

    // 5) Gérer la suppression de l'image courante
    deleteButton.addEventListener('click', () => {
        if (files.length === 0) return;

        // Si un blob a déjà été généré pour cette position, on le supprime
        if (croppedBlobs[currentIndex]) {
            croppedBlobs.splice(currentIndex, 1);
        }

        // Retirer le fichier courant du tableau
        files.splice(currentIndex, 1);

        // Si plus aucune image, on réinitialise toute l'interface
        if (files.length === 0) {
            resetAll();
            return;
        }

        // Si on supprimait la dernière image, on décale l'index
        if (currentIndex >= files.length) {
            currentIndex = files.length - 1;
        }

        loadImageAtIndex(currentIndex);
    });

    // 6) Gérer le bouton "Recadrer & Suivant" / "Recadrer & Télécharger"
    cropNextButton.addEventListener('click', () => {
        if (!cropperInstance) return;

        // Récupérer le canvas recadré à la taille exacte de la sélection
        const croppedCanvas = cropperInstance.getCroppedCanvas({
            fillColor: '#fff',
            imageSmoothingEnabled: true,
            imageSmoothingQuality: 'high',
        });

        // On convertit le canvas en blob WebP avec quality=1.0 (maximiser la qualité)
        croppedCanvas.toBlob(
            async (blob) => {
                croppedBlobs[currentIndex] = blob;

                // Si on n'est pas sur la dernière image, on passe à la suivante
                if (currentIndex < files.length - 1) {
                    currentIndex++;
                    loadImageAtIndex(currentIndex);
                    // Faire défiler à nouveau vers le haut du recadrage
                    previewContainer.scrollIntoView({ behavior: 'smooth' });
                } else {
                    // Dernière image recadrée → on télécharge
                    if (files.length === 1) {
                        // Une seule image → téléchargement direct
                        downloadBlobAsFile(blob, 'image-croppee.webp');
                        resetAll();
                    } else {
                        // Plusieurs images → on génère un ZIP
                        await downloadZipFromBlobs(croppedBlobs);
                        resetAll();
                    }
                }
            },
            // WebP avec quality 1.0 pour minimiser la perte
            'image/webp',
            1.0
        );
    });

    // --- Fonctions utilitaires ---

    // Télécharger un Blob sous un nom de fichier donné
    function downloadBlobAsFile(blob, filename) {
        const link = document.createElement('a');
        link.download = filename;
        link.href = URL.createObjectURL(blob);
        link.click();
        URL.revokeObjectURL(link.href);
    }

    // Générer un ZIP à partir d'un tableau de blobs et déclencher le téléchargement
    async function downloadZipFromBlobs(blobs) {
        const zip = new JSZip();
        blobs.forEach((blob, idx) => {
            zip.file(`image-${idx + 1}.webp`, blob);
        });
        const zipBlob = await zip.generateAsync({ type: 'blob' });
        downloadBlobAsFile(zipBlob, 'images-recadrees.zip');
    }

    // Réinitialiser totalement l'interface (après téléchargement ou suppression de tout)
    function resetAll() {
        files = [];
        croppedBlobs = [];
        currentIndex = 0;
        if (cropperInstance) {
            cropperInstance.destroy();
            cropperInstance = null;
        }
        imagePreview.src = '';
        previewContainer.classList.add('hidden');
        dropzone.classList.remove('hidden');
    }
</script>
